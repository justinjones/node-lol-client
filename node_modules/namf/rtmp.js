// Generated by CoffeeScript 1.6.3
(function() {
  var AMF0Decoder, AMF0Encoder, RTMPClient, RTMPCommand, RTMPHeader, RTMPMessage, RTMPProtocol, assert, hexy,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  hexy = require('hexy');

  assert = require('assert');

  AMF0Decoder = require('namf/amf0').Decoder;

  AMF0Encoder = require('namf/amf0').Encoder;

  RTMPHeader = (function() {
    RTMPHeader.FULL = 0x00;

    RTMPHeader.MESSAGE = 0x40;

    RTMPHeader.TIME = 0x80;

    RTMPHeader.SEPARATOR = 0xC0;

    RTMPHeader.MASK = 0xC0;

    function RTMPHeader(options) {
      var key, val;
      for (key in options) {
        if (!__hasProp.call(options, key)) continue;
        val = options[key];
        this[key] = val;
      }
      if (!this.channel) {
        this.channel = 0;
      }
      if (!this.time) {
        this.time = 0;
      }
      if (!this.streamId) {
        this.streamId = 0;
      }
      this.hdrdata = [];
      if (this.channel < 64) {
        this.hdrdata.push(this.channel);
      } else if (this.channel < (64 + 256)) {
        this.hdrdata.push(0x00);
        this.hdrdata.push(this.channel - 64);
      } else {
        this.hdrdata.push(0x01);
        this.hdrdata.push(((this.channel - 64) % 256) + ((this.channel - 64) / 256));
      }
    }

    RTMPHeader.prototype.toBytes = function(control) {
      var data, pack;
      data = [];
      data.push(this.hdrdata[0] | control);
      data.push.apply(data, this.hdrdata.slice(1));
      if (control !== RTMPHeader.SEPARATOR) {
        if (this.time < 0xFFFFFF) {
          pack = new Buffer(4);
          pack.writeUInt32BE(this.time, 0);
          data.push(pack[1], pack[2], pack[3]);
        } else {
          data.push(0xFF, 0xFF, 0xFF);
        }
        if (control !== RTMPHeader.TIME) {
          pack = new Buffer(4);
          pack.writeUInt32BE(this.size & 0xFFFFFFFF, 0);
          data.push(pack[1], pack[2], pack[3]);
          data.push(this.type);
          if (control !== RTMPHeader.MESSAGE) {
            pack = new Buffer(4);
            pack.writeUInt32LE(this.streamId & 0xFFFFFFFF, 0);
            data.push(pack[0], pack[1], pack[2], pack[3]);
          }
        }
      }
      if (this.time >= 0xFFFFFF) {
        pack = new Buffer(4);
        pack.writeUInt32BE(this.time & 0xFFFFFFFF, 0);
        data.push(pack[0], pack[1], pack[2], pack[3]);
      }
      return new Buffer(data);
    };

    return RTMPHeader;

  })();

  RTMPProtocol = (function() {
    RTMPProtocol.PING_SIZE = 1536;

    RTMPProtocol.DEFAULT_CHUNK_SIZE = 128;

    RTMPProtocol.PROTOCOL_CHANNEL_ID = 2;

    RTMPProtocol.READ_WIN_SIZE = 125000;

    RTMPProtocol.WRITE_WIN_SIZE = 1073741824;

    function RTMPProtocol(stream) {
      var _this = this;
      this.stream = stream;
      this.lastReadHeaders = {};
      this.lastWriteHeaders = {};
      this.incompletePackets = {};
      this.readChunkSize = this.writeChunkSize = RTMPProtocol.DEFAULT_CHUNK_SIZE;
      this.readWinSize = RTMPProtocol.READ_WIN_SIZE;
      this.writeWinSize = RTMPProtocol.WRITE_WIN_SIZE;
      this.readWinSize0 = this.writeWinSize0 = 0;
      this.nextChannelId = RTMPProtocol.PROTOCOL_CHANNEL_ID + 1;
      this.bytesRead = 0;
      this.socket.on('data', function(data) {
        return _this.bytesRead += data.length;
      });
    }

    RTMPProtocol.prototype.messageReceived = function(msg) {};

    RTMPProtocol.prototype.protocolMessage = function(msg) {};

    RTMPProtocol.prototype.parse = function() {
      return this.parseMessages();
    };

    RTMPProtocol.prototype.writeMessage = function(msg) {
      return this.stream.write(msg);
    };

    RTMPProtocol.prototype.parseMessages = function(data) {
      var CHANNEL_MASK, ack, channel, count, hdr, hdrsize, hdrtype, header, msg, newData, offset, oldData, packetData, size, sizeData, timestamp, timestampData;
      CHANNEL_MASK = 0x3F;
      offset = 0;
      msg = null;
      while (offset < data.length) {
        hdrsize = data[offset];
        offset += 1;
        channel = hdrsize & CHANNEL_MASK;
        if (channel === 0) {
          channel = 64 + data[offset];
          offset += 1;
        } else if (channel === 1) {
          channel = 64 + data[offset] + 256 * data[offset + 1];
          offset += 2;
        }
        hdrtype = hdrsize & RTMPHeader.MASK;
        header = null;
        if (hdrtype === RTMPHeader.FULL || this.lastReadHeaders[channel] === void 0) {
          header = new RTMPHeader({
            channel: channel
          });
          this.lastReadHeaders[channel] = header;
        } else {
          header = this.lastReadHeaders[channel];
        }
        if (hdrtype < RTMPHeader.SEPARATOR) {
          timestampData = new Buffer(4);
          timestampData[0] = 0x00;
          data.copy(timestampData, 1, offset, offset + 3);
          offset += 3;
          timestamp = timestampData.readUInt32BE(0);
          header.time = timestamp;
        }
        if (hdrtype < RTMPHeader.TIME) {
          sizeData = new Buffer(4);
          sizeData[0] = 0x00;
          data.copy(sizeData, 1, offset, offset + 3);
          offset += 3;
          header.size = sizeData.readUInt32BE(0);
          header.type = data[offset];
          offset += 1;
        }
        if (hdrtype < RTMPHeader.MESSAGE) {
          header.streamId = data.readUInt32LE(offset, offset + 4);
          offset += 4;
        }
        if (header.time === 0xFFFFFF) {
          header.extendedTime = data.readUInt32BE(offset, offset + 4);
          offset += 4;
        } else {
          header.extendedTime = null;
        }
        if (hdrtype === RTMPHeader.FULL) {
          header.currentTime = header.extendedTime || header.time;
          header.hdrtype = hdrtype;
        } else if (hdrtype === RTMPHeader.MESSAGE || hdrtype === RTMPHeader.TIME) {
          header.hdrtype = hdrtype;
        }
        oldData = this.incompletePackets[channel];
        count = Math.min(header.size - ((oldData != null ? oldData.length : void 0) || 0), this.readChunkSize);
        newData = data.slice(offset, offset + count);
        offset += count;
        if (oldData) {
          packetData = new Buffer(oldData.length + newData.length);
          oldData.copy(packetData);
          newData.copy(packetData, oldData.length);
        } else {
          packetData = newData;
        }
        if (this.readWinSize === !null) {
          if (this.bytesRead > (this.readWinSize0 + this.readWinSize)) {
            this.readWinSize0 = this.bytesRead;
            ack = new RTMPMessage();
            size = new Buffer(4);
            size.writeUInt32BE(this.readWinSize0, 0);
            ack.type = RTMPMessage.ACK;
            ack.data = size;
            this.writeMessage(ack);
          }
        }
        if (packetData.length < header.size) {
          this.incompletePackets[channel] = packetData;
        } else {
          if (hdrtype === RTMPHeader.MESSAGE || hdrtype === RTMPHeader.TIME) {
            header.currentTime = (header.currentTime || 0) + (header.extendedTime || header.time);
          } else if (hdrtype === RTMPHeader.SEPARATOR) {
            if (header.hdrtype === RTMPHeader.MESSAGE || header.hdrtype === RTMPHeader.TIME) {
              header.currentTime = (header.currentTime || 0) + (header.extendedTime || header.time);
            }
          }
          if (packetData.length === header.size) {
            if (this.incompletePackets[channel]) {
              delete this.incompletePackets[channel];
            }
          } else {

          }
          hdr = new RTMPHeader({
            channel: header.channel,
            time: header.currentTime,
            size: header.size,
            type: header.type,
            streamId: header.streamId
          });
          msg = new RTMPMessage(hdr, packetData);
        }
      }
      return msg;
    };

    return RTMPProtocol;

  })();

  RTMPClient = (function(_super) {
    __extends(RTMPClient, _super);

    function RTMPClient(socket) {
      var _this = this;
      this.socket = socket;
      this.parseMessages = __bind(this.parseMessages, this);
      this.parseFullData = __bind(this.parseFullData, this);
      this.parseData = __bind(this.parseData, this);
      this._nextCallId = 1;
      this._callbacks = {};
      this._timeouts = {};
      this.streams = {};
      this.objectEncoding = 0;
      this.lastReadHeaders = {};
      this.lastWriteHeaders = {};
      this.incompletePackets = {};
      this.readChunkSize = this.writeChunkSize = RTMPProtocol.DEFAULT_CHUNK_SIZE;
      this.readWinSize = RTMPProtocol.READ_WIN_SIZE;
      this.readWinSize = 1700000;
      this.writeWinSize = RTMPProtocol.WRITE_WIN_SIZE;
      this.readWinSize0 = this.writeWinSize0 = 0;
      this.nextChannelId = RTMPProtocol.PROTOCOL_CHANNEL_ID + 1;
      this.bytesRead = 0;
      if (this.socket) {
        this.socket.on('data', function(data) {
          return _this.bytesRead += data.length;
        });
      }
    }

    RTMPClient.prototype.handshake = function(cb) {
      var clientResponse, handleHandshake1, handleHandshake2, handshake1,
        _this = this;
      handshake1 = new Buffer(1537);
      handshake1[0] = 0x03;
      clientResponse = null;
      handleHandshake1 = function(data) {
        _this.socket.removeListener('data', handleHandshake1);
        if (data.length !== 1537 && data.length !== 3073) {
          cb(new Error('Handshake response was incorrect size.'));
        }
        if (data.length === 1537) {
          clientResponse = data.slice(1);
          _this.socket.addListener('data', handleHandshake2);
        }
        if (data.length === 3073) {
          clientResponse = data.slice(1, 1537);
          return handleHandshake2(data.slice(1537));
        }
      };
      handleHandshake2 = function(data) {
        _this.socket.removeListener('data', handleHandshake2);
        if (data.length !== 1536) {
          return cb(new Error('Handshake response was incorrect size.'));
        } else {
          _this.socket.write(clientResponse);
          _this.socket.on('data', _this.parseData);
          return cb(null);
        }
      };
      this.socket.addListener('data', handleHandshake1);
      return this.socket.write(handshake1);
    };

    RTMPClient.prototype.parseData = function(data) {
      var CHANNEL_MASK, buf, channel, dataNeeded, extraData, hdrsize, hdrtype, header, newData, offset, sizeData, timestamp, timestampData, totalSize;
      extraData = null;
      if (this.partialMessage) {
        totalSize = this.partialMessage.header.size + Math.floor(this.partialMessage.header.size / 128);
        if (Math.floor(this.partialMessage.header.size / 128) === (this.partialMessage.header.size / 128)) {
          totalSize -= 1;
        }
        totalSize += this.partialMessage.header.hdrsize;
        dataNeeded = totalSize - this.partialMessage.data.length;
        newData = null;
        if (dataNeeded < data.length) {
          newData = data.slice(0, dataNeeded);
          extraData = data.slice(newData.length);
        } else {
          newData = data;
        }
        buf = new Buffer(this.partialMessage.data.length + newData.length);
        this.partialMessage.data.copy(buf, 0);
        newData.copy(buf, this.partialMessage.data.length);
        this.partialMessage.data = buf;
        if (this.partialMessage.data.length >= totalSize) {
          this.parseFullData(this.partialMessage.header, this.partialMessage.data);
          this.partialMessage = null;
          if (extraData) {
            return this.parseData(extraData);
          }
        }
      } else {
        CHANNEL_MASK = 0x3F;
        offset = 0;
        header = null;
        hdrsize = data[offset];
        offset += 1;
        channel = hdrsize & CHANNEL_MASK;
        if (channel === 0) {
          channel = 64 + data[offset];
          offset += 1;
        } else if (channel === 1) {
          channel = 64 + data[offset] + 256 * data[offset + 1];
          offset += 2;
        }
        hdrtype = hdrsize & RTMPHeader.MASK;
        if (hdrtype === RTMPHeader.FULL || this.lastReadHeaders[channel] === void 0) {
          header = new RTMPHeader({
            channel: channel
          });
          this.lastReadHeaders[channel] = header;
        } else {
          header = this.lastReadHeaders[channel];
        }
        if (hdrtype < RTMPHeader.SEPARATOR) {
          timestampData = new Buffer(4);
          timestampData[0] = 0x00;
          data.copy(timestampData, 1, offset, offset + 3);
          offset += 3;
          timestamp = timestampData.readUInt32BE(0);
          header.time = timestamp;
        }
        if (hdrtype < RTMPHeader.TIME) {
          sizeData = new Buffer(4);
          sizeData[0] = 0x00;
          data.copy(sizeData, 1, offset, offset + 3);
          offset += 3;
          header.size = sizeData.readUInt32BE(0);
          header.type = data[offset];
          offset += 1;
        }
        if (hdrtype < RTMPHeader.MESSAGE) {
          header.streamId = data.readUInt32LE(offset, offset + 4);
          offset += 4;
        }
        if (header.time === 0xFFFFFF) {
          header.extendedTime = data.readUInt32BE(offset, offset + 4);
          offset += 4;
        } else {
          header.extendedTime = null;
        }
        if (hdrtype === RTMPHeader.FULL) {
          header.currentTime = header.extendedTime || header.time;
          header.hdrtype = hdrtype;
        } else if (hdrtype === RTMPHeader.MESSAGE || hdrtype === RTMPHeader.TIME) {
          header.hdrtype = hdrtype;
        }
        this.partialMessage = {
          header: header
        };
        totalSize = this.partialMessage.header.size + Math.floor(this.partialMessage.header.size / 128);
        if (Math.floor(this.partialMessage.header.size / 128) === (this.partialMessage.header.size / 128)) {
          totalSize -= 1;
        }
        totalSize += offset;
        this.partialMessage.header.hdrsize = offset;
        dataNeeded = Math.min(totalSize, data.length);
        if (data.length > dataNeeded) {
          this.partialMessage.data = data.slice(0, dataNeeded);
          extraData = data.slice(this.partialMessage.data.length);
        } else {
          this.partialMessage.data = data;
        }
        if (this.partialMessage.data.length >= totalSize) {
          this.parseFullData(this.partialMessage.header, this.partialMessage.data);
          this.partialMessage = null;
          if (extraData) {
            return this.parseData(extraData);
          }
        }
      }
    };

    RTMPClient.prototype.parseFullData = function(header, data) {
      var buf, chunkMarkers, count, hdr, msg, newData, offset, packetData;
      data = data.slice(header.hdrsize);
      offset = 0;
      chunkMarkers = 0;
      packetData = null;
      while (offset < data.length && offset < (header.size + chunkMarkers)) {
        if (packetData) {
          offset += 1;
          chunkMarkers += 1;
        }
        count = Math.min((header.size + chunkMarkers) - offset, this.readChunkSize);
        newData = data.slice(offset, offset + count);
        offset += count;
        if (packetData) {
          buf = new Buffer(packetData.length + newData.length);
          packetData.copy(buf);
          newData.copy(buf, packetData.length);
          packetData = buf;
        } else {
          packetData = newData;
        }
      }
      hdr = new RTMPHeader({
        channel: header.channel,
        time: header.currentTime,
        size: header.size,
        type: header.type,
        streamId: header.streamId
      });
      msg = new RTMPMessage(hdr, packetData);
      return this.messageReceived(msg);
    };

    RTMPClient.prototype.parseMessages = function(data) {
      var CHANNEL_MASK, ack, channel, count, hdr, hdrsize, hdrtype, header, msg, newData, offset, oldData, oldOffset, packetData, parseHeader, size, sizeData, timestamp, timestampData;
      CHANNEL_MASK = 0x3F;
      offset = 0;
      msg = null;
      parseHeader = true;
      while (offset < data.length) {
        oldOffset = offset;
        hdrsize = data[offset];
        offset += 1;
        channel = hdrsize & CHANNEL_MASK;
        if (channel === 0) {
          channel = 64 + data[offset];
          offset += 1;
        } else if (channel === 1) {
          channel = 64 + data[offset] + 256 * data[offset + 1];
          offset += 2;
        }
        hdrtype = hdrsize & RTMPHeader.MASK;
        header = null;
        if (hdrtype === RTMPHeader.FULL && (channel === 2 || channel === 3)) {
          header = new RTMPHeader({
            channel: channel
          });
          this.lastReadHeaders[channel] = header;
        } else if (this.lastReadHeaders['3']) {
          header = this.lastReadHeaders['3'];
          parseHeader = false;
        } else {
          header = this.lastReadHeaders[channel];
        }
        if (parseHeader) {
          if (hdrtype < RTMPHeader.SEPARATOR) {
            timestampData = new Buffer(4);
            timestampData[0] = 0x00;
            data.copy(timestampData, 1, offset, offset + 3);
            offset += 3;
            timestamp = timestampData.readUInt32BE(0);
            header.time = timestamp;
          }
          if (hdrtype < RTMPHeader.TIME) {
            sizeData = new Buffer(4);
            sizeData[0] = 0x00;
            data.copy(sizeData, 1, offset, offset + 3);
            offset += 3;
            header.size = sizeData.readUInt32BE(0);
            header.type = data[offset];
            offset += 1;
          }
          if (hdrtype < RTMPHeader.MESSAGE) {
            header.streamId = data.readUInt32LE(offset, offset + 4);
            offset += 4;
          }
          if (header.time === 0xFFFFFF) {
            header.extendedTime = data.readUInt32BE(offset, offset + 4);
            offset += 4;
          } else {
            header.extendedTime = null;
          }
          if (hdrtype === RTMPHeader.FULL) {
            header.currentTime = header.extendedTime || header.time;
            header.hdrtype = hdrtype;
          } else if (hdrtype === RTMPHeader.MESSAGE || hdrtype === RTMPHeader.TIME) {
            header.hdrtype = hdrtype;
          }
        }
        oldData = this.incompletePackets['3'];
        count = Math.min(header.size - ((oldData != null ? oldData.length : void 0) || 0), this.readChunkSize, data.length - offset);
        newData = data.slice(offset, offset + count);
        offset += count;
        if (oldData) {
          packetData = new Buffer(oldData.length + newData.length);
          oldData.copy(packetData);
          newData.copy(packetData, oldData.length);
        } else {
          packetData = newData;
        }
        if (this.bytesRead > (this.readWinSize0 + this.readWinSize)) {
          this.readWinSize0 = this.bytesRead;
          ack = new RTMPMessage();
          size = new Buffer(4);
          size.writeUInt32BE(this.readWinSize0, 0);
          ack.type = RTMPMessage.ACK;
          ack.data = size;
          ack.size = ack.data.length;
          this.writeMessage(ack);
        }
        if (packetData.length < header.size) {
          this.incompletePackets['3'] = packetData;
          this.incompletePackets[channel] = packetData;
        } else {
          if (hdrtype === RTMPHeader.MESSAGE || hdrtype === RTMPHeader.TIME) {
            header.currentTime = (header.currentTime || 0) + (header.extendedTime || header.time);
          } else if (hdrtype === RTMPHeader.SEPARATOR) {
            if (header.hdrtype === RTMPHeader.MESSAGE || header.hdrtype === RTMPHeader.TIME) {
              header.currentTime = (header.currentTime || 0) + (header.extendedTime || header.time);
            }
          }
          if (packetData.length === header.size) {
            if (this.incompletePackets[channel]) {
              delete this.incompletePackets[channel];
            }
            if (this.incompletePackets['3']) {
              delete this.incompletePackets['3'];
            }
          } else {

          }
          hdr = new RTMPHeader({
            channel: header.channel,
            time: header.currentTime,
            size: header.size,
            type: header.type,
            streamId: header.streamId
          });
          msg = new RTMPMessage(hdr, packetData);
          this.messageReceived(msg);
          return msg;
          if (msg.type === RTMPMessage.ACK) {
            console.log(hexy.hexy(data));
          }
        }
      }
    };

    RTMPClient.prototype.send = function(cmd, cb) {
      var callId, closeSocket, timeoutId, _ref,
        _this = this;
      _ref = [this._nextCallId, this.objectEncoding === 0 && RTMPMessage.RPC || RTMPMessage.RPC3], cmd.id = _ref[0], cmd.type = _ref[1];
      callId = this._nextCallId;
      this._nextCallId += 1;
      this._callbacks[callId] = cb;
      closeSocket = function() {
        var key, timeout, _ref1, _results;
        console.log('Timeout reached, closing socket.');
        if (!_this.broken) {
          _this.broken = true;
          _this.socket.destroySoon();
        }
        _ref1 = _this._timeouts;
        _results = [];
        for (key in _ref1) {
          timeout = _ref1[key];
          _results.push(clearTimeout(timeout));
        }
        return _results;
      };
      timeoutId = setTimeout(closeSocket, 10000);
      this._timeouts[callId] = timeoutId;
      return this.writeMessage(cmd.toMessage());
    };

    RTMPClient.prototype.writeMessage = function(message) {
      var control, count, data, hdr, hdrData, hdrOptions, header, newData, offset, sliceData, _ref, _ref1, _ref2;
      header = null;
      control = null;
      if (this.lastWriteHeaders[message.streamId]) {
        header = this.lastWriteHeaders[message.streamId];
      } else {
        if (this.nextChannelId <= RTMPProtocol.PROTOCOL_CHANNEL_ID) {
          this.nextChannelId = RTMPProtocol.PROTOCOL_CHANNEL_ID + 1;
        }
        header = new RTMPHeader({
          channel: this.nextChannelId
        });
        this.nextChannelId += 1;
      }
      if (message.type < RTMPMessage.AUDIO) {
        header = new RTMPHeader({
          channel: RTMPProtocol.PROTOCOL_CHANNEL_ID,
          type: RTMPMessage.MESSAGE
        });
      }
      if (header.streamId !== message.streamId || header.time === 0 || message.time <= header.time) {
        _ref = [message.streamId, message.type, message.size, message.time, message.time], header.streamId = _ref[0], header.type = _ref[1], header.size = _ref[2], header.time = _ref[3], header.delta = _ref[4];
        control = RTMPHeader.FULL;
      } else if (header.size !== message.size || header.type !== message.type) {
        _ref1 = [message.type, message.size, message.time, message.time], header.type = _ref1[0], header.size = _ref1[1], header.time = _ref1[2], header.delta = _ref1[3];
        control = RTMPHeader.MESSAGE;
      } else {
        _ref2 = [message.time, message.time], header.time = _ref2[0], header.delta = _ref2[1];
        control = RTMPHeader.TIME;
      }
      hdrOptions = {
        channel: header.channel,
        size: header.size,
        type: header.type,
        streamId: header.streamId
      };
      if (control === RTMPHeader.MESSAGE || control === RTMPHeader.TIME) {
        hdrOptions['time'] = header.delta;
      } else {
        hdrOptions['time'] = header.time;
      }
      hdr = new RTMPHeader(hdrOptions);
      data = new Buffer(0);
      offset = 0;
      while (offset < message.data.length) {
        hdrData = hdr.toBytes(control);
        count = Math.min(this.writeChunkSize, message.data.length - offset);
        sliceData = message.data.slice(offset, offset + count);
        offset += count;
        newData = new Buffer(data.length + hdrData.length + sliceData.length);
        data.copy(newData, 0);
        hdrData.copy(newData, data.length);
        sliceData.copy(newData, data.length + hdrData.length);
        data = newData;
        control = RTMPHeader.SEPARATOR;
      }
      if (message.type < RTMPMessage.AUDIO) {
        hexy = require('hexy');
        console.log(hexy.hexy(data));
      }
      if (this.socket.writable) {
        return this.socket.write(data);
      }
    };

    RTMPClient.prototype.messageReceived = function(msg) {
      var cb, cmd;
      if ((msg.type === RTMPMessage.RPC || msg.type === RTMPMessage.RPC3) && msg.streamId === 0) {
        cmd = RTMPCommand.fromMessage(msg);
        if (cmd.name === '_error') {
          this.socket.destroySoon();
        }
        if (cb = this._callbacks[cmd.id]) {
          clearTimeout(this._timeouts[cmd.id]);
          delete this._timeouts[cmd.id];
          if (cmd.name === '_error') {
            cb(cmd);
          } else {
            cb(null, cmd);
          }
          return delete this._callbacks[cmd.id];
        }
      } else if (msg.type === RTMPMessage.ACK) {
        console.log('Got ack');
        return this.writeWinSize0 = msg.data.readUInt32BE(0);
      } else if (msg.type === RTMPMessage.WIN_ACK_SIZE) {
        return console.log(msg);
      } else {
        return console.log('UNKNOWN MSG?', msg);
      }
    };

    return RTMPClient;

  })(RTMPProtocol);

  RTMPCommand = (function() {
    function RTMPCommand(type, name, id, data, args) {
      this.type = type;
      this.name = name;
      this.id = id;
      this.data = data;
      this.args = args != null ? args : [];
    }

    RTMPCommand.fromMessage = function(message) {
      var cmd, data, decoder;
      if ([RTMPMessage.RPC, RTMPMessage.RPC3, RTMPMessage.DATA, RTMPMessage.DATA3].indexOf(message.type) === -1) {
        throw "Not a valid message type for a command.";
      }
      if (message.data.length === 0) {
        throw "Zero length message data.";
      }
      data = null;
      if (message.type === RTMPMessage.RPC3 || message.type === RTMPMessage.DATA3) {
        data = message.data.slice(1);
      } else {
        data = message.data;
      }
      cmd = new RTMPCommand();
      cmd.type = message.type;
      decoder = new AMF0Decoder(data);
      cmd.name = decoder.readValue();
      if (message.type === RTMPMessage.RPC || message.type === RTMPMessage.RPC3) {
        cmd.id = decoder.readValue();
        cmd.data = decoder.readValue();
      } else {
        cmd.id = 0;
      }
      cmd.args = [];
      if (cmd.name === '_error') {
        console.log(cmd);
        console.log(hexy.hexy(data));
        return cmd;
      }
      while (decoder.offset < decoder.buffer.length) {
        cmd.args.push(decoder.readValue());
      }
      return cmd;
    };

    RTMPCommand.prototype.toMessage = function() {
      var arg, buffer, encoder, msg, out, _i, _j, _len, _len1, _ref, _ref1;
      msg = new RTMPMessage();
      msg.type = this.type;
      encoder = new AMF0Encoder();
      encoder.writeValue(this.name);
      if (msg.type === RTMPMessage.RPC || msg.type === RTMPMessage.RPC3) {
        encoder.writeValue(this.id);
        encoder.writeValue(this.data || null);
      }
      if (msg.type === RTMPMessage.RPC) {
        _ref = this.args;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          arg = _ref[_i];
          encoder.writeValue(arg);
        }
      } else if (msg.type === RTMPMessage.RPC3) {
        _ref1 = this.args;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          arg = _ref1[_j];
          encoder.writeAMF3(arg);
        }
      }
      out = encoder.getBuffer();
      if (msg.type === RTMPMessage.RPC3) {
        buffer = new Buffer(out.length + 1);
        buffer[0] = 0x00;
        out.copy(buffer, 1);
      } else {
        buffer = out;
      }
      msg.data = buffer;
      msg.size = buffer.length;
      return msg;
    };

    return RTMPCommand;

  })();

  RTMPMessage = (function() {
    var _ref;

    _ref = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x08, 0x09, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14], RTMPMessage.CHUNK_SIZE = _ref[0], RTMPMessage.ABORT = _ref[1], RTMPMessage.ACK = _ref[2], RTMPMessage.USER_CONTROL = _ref[3], RTMPMessage.WIN_ACK_SIZE = _ref[4], RTMPMessage.SET_PEER_BW = _ref[5], RTMPMessage.AUDIO = _ref[6], RTMPMessage.VIDEO = _ref[7], RTMPMessage.DATA3 = _ref[8], RTMPMessage.SHAREDOBJ3 = _ref[9], RTMPMessage.RPC3 = _ref[10], RTMPMessage.DATA = _ref[11], RTMPMessage.SHAREDOBJ = _ref[12], RTMPMessage.RPC = _ref[13];

    function RTMPMessage(header, data) {
      this.header = header;
      this.data = data;
      if (!this.header) {
        this.header = new RTMPHeader();
      }
      if (this.header.type) {
        this.type = this.header.type;
      }
      if (this.header.size) {
        this.size = this.header.size;
      }
      if (this.header.streamId) {
        this.streamId = this.header.streamId;
      }
      if (!this.streamId) {
        this.streamId = 0;
      }
      if (this.header.time) {
        this.time = this.header.time;
      }
    }

    return RTMPMessage;

  })();

  exports.RTMPClient = RTMPClient;

  exports.RTMPCommand = RTMPCommand;

}).call(this);
